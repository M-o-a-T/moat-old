=====
block
=====

This module implements two quick-and-dirty compound statements to
control execution flow.

------
block:
------

This just groups more than one statement into a sequence. It's not very
useful by itself, but a good "if true" replacement.

------
async:
------

Like "block:", but does *not* wait for completion before continuing to
interpret input: the statements will run in a parallel thread.

	load logging
	load wait
	async:
		log TRACE One
		wait for 1
		log TRACE two

A "skip next" command inside the async: block will terminate executing
that block, but cannot have any effect beyond that.

----------
skip this:
----------

This will cause the following block to not be executed.
(It still needs to be composed of known words.)
It's a handy "comment this out" statement.

====
bool
====

Simple conditionals "true" and "false". See 'ifelse' for details.

=======
example
=======

A snippet of module loader code to help you get going.

====
help
====

This module implements the help command.

"help" is able to examine sub-commands, so if the "foo" command has a
sub-command named "bar", "help foo bar" will list its info.

Of course, if you also happen to have a top-level "foo bar" command,
you're SOL. So don't do that. ☺

======
ifelse
======

This module implements basic conditional blocks.

	laod ifelse
	load bool
	load logging
	block:
		if true:
			log TRACE "Everything is OK."
		else:
			log PANIC "Something is *seriously* broken!"

"else if" is also available.

"else" does not work at top level, due to an implementation
decision that's difficult to circumvent, but you can always use a block:
wrapper (as in the example, above).

This module does not by itself implement anything you can actually test
for; that's in other modules.

"help conditions" lists which conditions you can test for.

All conditions can be negated by writing "if not" instead of "if".

====
list
====

This module implements a couple of rarely-used commands to list and
examine internal data structures.

-----------
list module
-----------

Shows the list of loaded modules, terminated by a single dot.

You can append the name of a loaded module to examine details.

-----------
list worker
-----------

Shows the list of program snippets that listen for events, ordered by
priority.

You can append the name of a worker to examine details.

=======
logging
=======

This module controls debug output.

---
log
---

Without arguments, it shows a list of the available logging levels,
sorted by priority.

	log

With one argument, it states that debug output of all levels up to the
one specified by the argument shoudl be reported.

	log DEBUG

With more than one argument, the first argument specifies the level at
which the rest of the arguments will get logged.

	log TRACE "You are here."

Log output will go to all terminals which listen to logging at that level
(or less).

========
on_event
========

This is the main event handler module. It translates system events to
executed code, which usually includes triggering even more events.

---
on:
---

Execute statements when an event happens. The parameters of the event
need to correspond 1:1 to the parameters of the "on:" command.

A limited form of wildcard is available: A parameter "*" matches
anything; the actual value is available as "$1" (for the first '*') etc.
Alternately, you can name the parameters:

	load logging
	on foo *whatever:
		name FooBar
		prio 10
		log TRACE "Yes, we get to foo the" $whatever "now!"
		# and whatever else you'd like to do here

	load trigger
	trigger foo bar

Right now there is no support for pattern matching or variable number of
arguments. (One solution is to design your event names in such a way that
you don't need that.)

name
----

This sub-statement names this particular event handler.

Event handlers have system-assigned numbers as well as names, so you can
still delete a handler without naming it.

prio
----

Priority. Default priority is 50. Allowed priorities go from 0 to 100.

Lower-priority handlers are executed first. Only one matching handler
per priority gets executed; which one, depends on random chance (and,
of course, any attached conditions).

This does mean that higher-priority handlers do not start running until
their lower-priority counterparts are completed. If that is not what you
want, use an async: block in the low-priority handler.

---------
skip next
---------

This command skips everything that comes after it. This includes not
only every command afterwards, but also all higher-priority event
handlers.

One important usage of this is an alarm system. If you have turned on
your alarm system, you want something entirely different to happen if,
say, somebody turns on the office light.

	load trigger
	on switch * office *:
		prio 10
		only if state on alarm
		trigger alert intruder
		skip next
	on switch on office whatever:
		do-whatever-to-turn-this-light-on

This means that you can have localized knowledge of special requirements
and don't need to sprinkle "don't do anything if the alarm is on"
conditions throughout your code.

Not that the effects of a "skip next" end at the end of an event; they
do not propagate through a "sync trigger" handler:

	on foo:
		log TRACE one
		sync trigger bar
		log TRACE two
	on bar:
		skip next
		log TRACE "beware: this is ignored"

will still print

	TRACE> one
	TRACE> two

-------
list on
-------

Lists all event handlers.

You can append the name or number of a handler to show details for
that handler.

------
del on
------

Deletes a handler from the system. You need to specify either its number
or its name.

	del on FooBar

------------
if exists on
------------

A test whether a handler exists. Handy to avoid a runtime error if you
don't know whether one exists.

	if exists on FooBar:
		del on FooBar


=====
state
=====

This module limits state variables. These are not yet persistent, but
they will be.

---------
set state
---------

Sets a state to some value.

	set state on livingroom lamp1

This will trigger an event if the old state was not "on":

	state - on livingroom lamp1

"-" is used when the state variable is new.

The event is processed synchronously. It is an error for an event
handler to change the same state variables.

For this reason, you need to wrap any activity that's either long-term,
or likely to change the state again, in an async: block. In other
words, this is broken and will cause you a lot of headache:

	# DO NOT DO THIS
	load onewire
	load on_event
	load wait
	load trigger

	on state * on outside *lamp:
		trigger onewire switch on outside $lamp
		wait for 5min:
			name outside $lamp
		trigger onewire switch off outside $lamp

The correct solution would be, depending on whether you want the switch
to prolong the timeout …:

	# DO THIS (the switch turns off the lamp)
	load block
	load ifelse

	on state * on outside *lamp:
		if exists wait outside $lamp:
			wait for 5min:
				name outside $lamp
				update
		else:
			async:
				trigger onewire switch on outside $lamp
				wait for 5min:
					name outside $lamp
				trigger onewire switch off outside $lamp

… or turn the lamp off prematurely:

	# DO THIS (the switch turns off the lamp)
	on state * on outside *lamp:
		async:
			if exists wait outside $lamp:
				del wait outside $lamp
			else:
				trigger onewire switch on outside $lamp
				wait for 5min:
					name outside $lamp
			trigger onewire switch off outside $lamp

Note that in the last example, the trigger statement is outside the if:
statement. That is intentional; see "del wait", below, for details.

---------
del state
---------

Causes the system to forget a state variable. A notification event is
triggered:

	state on - livingroom lamp1

The rules on events, above, still apply.

----------
list state
----------

Shows all state variables.

You can append the name of a variable to show additional details.

---------
var state
---------

Sometimes you need a state for further processing.

Arguments are the name of the variable, and the state name.

	block:
		var state light livingroom lamp1
		log DEBUG "The light is" $light

-----
Tests
-----

state
-----

True if a state has a particular value.

	if state on livingroom lamp1:
		log DEBUG "Save energy, man!"

last state
----------

True if a state had a particular value before it was changed to the
current one. As above, the previous value for a new state is "-".

exists state
------------

True if the state has been defined at all.

	if exists state NAME:
		log DEBUG "Yay!"

locked state
------------

True if the state is currently being updated, i.e. an event handler is
working (and blocking!) on it.

Ideally, you should split up your design into more events instead of
doing a test like this, but if you *have* to …

	async:
		while locked state SOMETHING:
			wait for 1 sec
		set state SOMETHING off

Obviously, a loop like this should never run synchronously.



====
time
====

Sometimes you need the current (or some future) time for further
processing.

--------
var time
--------

This statement assigns the current time, or some attribute thereof, to a
variable.

	block:
		var time now + 10sec
		wait until = $now

=======
trigger
=======

This module implements a way to create new events from script code.

-------
trigger
-------

Launches a new event. The event is run asynchronously, i.e. execution
will continue while the event is processed.

	trigger foo bar

------------
sync trigger
------------

The event is run synchronously, i.e. execution will stall until this
event has been processed. That means if the trigger says

	on foo bar:
		switch on lamp
		wait for 1h
		switch off lamp

then the statement after the "sync trigger" will be executed exactly one
hour later.

====
wait
====

This module implements a method to wait for a specified amount of time.

--------
wait for
--------

This statement will delay execution by the specified amount.

	wait for 10min + 5sec

You can use it as a compound statement to specify details.


name
----

Assign a name to a wait statement. This name causes the waiter to be
unique, i.e. there can only be one wait statement with that name in the
whole system. If you try to execute a wait statement with the same
name as one that's still pending, an error will be triggered.

	wait for 5min:
		name "Brew some tea"

If you do not name a wait statement, it will have a system-assigned
unique name.

update
------

This marks a wait: statement as updating another waiter, instead of
waiting itself. For example:

	async:
		wait for 10sec:
			name Test
		trigger FooBar

	wait for 1sec:
		name Test
		update
	
	trigger DoNow

will trigger the FooBar event after one second; the DoNow event will
trigger immediately. Obviously, both wait statements need the same name.
An error will be raised if the original statement is no longer active.

----------
wait until
----------

This powerful statement lets you wait until some (fixed) conditions
related to the current time are true.

	async:
		wait until 0 min 0 sec
		log DEBUG full hour

If the conditions are already true, this statement will not wait at all.

---------------
wait until next
---------------

Like above, except that it'll wait until the next time the statement is
true.

	async:
		while True:
			wait until next 0 min
			trigger play sound "hourly chime.ogg"

This will prevent repeating the gong for a full minute. ;-)

----------
wait while
----------

This will wait until the condition is no longer true.
The above could therefore also have been written as:

	async:
		while True:
			wait while 0 min
			wait until 0 min
			trigger play sound "hourly chime.ogg"

except that it's ugly. ☺

---------
list wait
---------

This command shows which wait statements are currently active.

You can append the name of a wait statement to show additional details.

--------
del wait
--------

Cancels a given wait. The statements which waited for it are *not*
executed — this includes stuff in upper blocks, other event handlers
which tried to process whatever was blocked by the wait, etc.

This is the reason why, in the last example under "set state", above,
the command to turn off the lamp is outside the if: statement.

If you do want these statements to run, update the waiter to zero
seconds instead of canceling it.


-----
Tests
-----

if wait before/after
--------------------

You can use this test to find out whether an event triggers before or
after another one.

	async:
		wait for 10min:
			name YAWN
	block:
		var time tomorrow time += 0h 0min 0sec
		if wait after $tomorrow YAWN:
			log DEBUG the YAWN timer ends on a different day


if exists wait
--------------

You can use this statement to test if a waiter is pending.

See the example under "set state", above.


if locked wait
--------------

You can use this statement to test whether a notification event on that
waiter is running.
