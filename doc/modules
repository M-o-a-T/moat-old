=====
block
=====

This module implements two quick-and-dirty compound statements to
control execution flow.

------
block:
------

This just groups more than one statement into a sequence. It's not very
useful by itself, but a good "if true" replacement.

------
async:
------

Like "block:", but does *not* wait for completion before continuing to
interpret input: the statements will run in a parallel thread.

	load logging
	load wait
	async:
		log TRACE One
		wait for 1
		log TRACE two

A "skip next" command inside the async: block will terminate executing
that block, but cannot have any effect beyond that.

----------
skip this:
----------

This will cause the following block to not be executed.
(It still needs to be composed of known words.)
It's a handy "comment this out" statement.

====
bool
====

This module provides a cuple of basic conditionals. 
See “ifelse” for details.

true
----

Always true.

false
-----

Always false.

null ARG
--------

This conitional tests whether the argument is not set.
This is important e.g. for monitoring.

	monitor foo:
		…
	on monitor value *FOO foo:
		var monitor OLDFOO foo
		if null $OLDFOO:
			log TRACE first time fooing around
		else:
			log TRACE checking $FOO against old $OLDFOO

equal A B
---------

Test if A and B are equal (either both null, or both same-valued
floating point numbers, or identical strings).

Obviously, this statement makes sense only if at least one of these
values is a variable. ☺

"less" and "greater" tests are also available.


======
errors
======

Basic error handling.

Usually, an error causes all processing to be aborted which waits for
the failed statement to complete. In a non-async block, that happens
to be the entire rest of the script. This module provides some ways to
change that, as well as a command to explicitly trigger an error.

---
try
---

This command catches all errors which happen inside.

	try:
		set onewire FOO nonexistent

-----
catch
-----

This command needs to follow a ‹try› or ‹catch› block. It grabs the
error from that block.

	block:
		try:
			trigger error foo bar
		catch:
			log DEBUG Somebody did a $1 with a $2

As you see, the error's parameters are passed in.

As an alternate form, you may mention the parameters explicitly.
If the error has not been triggered manually, or does not fit the list
in some way, processing continues to the next ‹catch› block.

	block:
		try:
			trigger error foo bar
		catch foo *what:
			log DEBUG Somebody must have been fooing around with the $what
		catch:
			log DEBUG Somebody did a $1 with a $2

Finally, named system errors can be caught:
	
	block:
		try:
			log TRACE $foobar
		catch KeyError:
			log DEBUG somebody did something stupid
			log error DEBUG

Errors within the ‹catch› block fall down to the next ‹catch› statement.
If there is none, the error is handled normally.


-------------
trigger error
-------------

As seen in the above examples, this statement will cause an error to be
emitted.

	block:
		try:
			block:
				trigger error foo bar
				log TRACE this will never be seen
			log TRACE Neither will this be
		catch:
			log TRACE HEY we got an error of $1

------------
report error
------------

Caught errors are normally not reported because the ‹catch› block is
supposed to handle them. If you want (or need) to, however, you can 

	block:
		try:
			trigger error foo bar
		catch:
			log error DEBUG


=======
example
=======

A snippet of module loader code to help you get going.


==========
fs20switch
==========

Use this module to register FS20 devices.

HomEvenT uses this registration only for naming, but doesn't
distinguish between senders and receivers, since it treats incoming
signals as mere events — you need to specify any more convoluted logic
in your own code.

Incoming messages will be reported as events, of course; see the events
documentation for details.

--------------------------
fs20 switch HOUSECODE NAME
--------------------------

This command declares a group of FS20 devices which share a common
“house code”, an 8-digit sequence (digits 1,2,3,4 only ⇒ in effect a
16-bit number).

add DEVCODE NAME
----------------

This subcommand is used to declare a device.
The device code is four digits long (1 to 4, again).

	fs20 switch 12344321 inside actors:
		add 2143 living room light

You can use the same command to modify an existing house code;
simply use either the code or the name, but not both:

	fs20 switch 12344321:
		del 2143 living room light
		add 2144 living room light

Note that the broadcast / group control codes, which are defined as
having "44" in the first and/or last two digits of the device code,
are not handled by HomEvenT in any special way. This is intentional:
your HomEvenT code needs to know (and document) _anyway_ which signal
affects which device.


---------
send fs20
---------

Send a FS20 message.

	set fs20 on - living room light

This of course does not guarantee that the lights really turn on.
Among other reasons, FS20 is not a bidirectional protocol, so messages
can and do get lost. A common workaround is to add a timer which, when
somebody pushes the light-on button again within two seconds or so,
causes the command to repeat instead of turning the light back off.


======
fs20tr
======

This module allows you to use external processes to send and receive
FS20 datagrams.

The datagram format is simple: The complete frame, encoded in hex.
The checksum is not treated in any special way and arbitrary datagram
lengths are supported.

Note that regulations limit any one sender to take up at most 1% of he
total available bandwidth. This module does not yet enforce this limit.

The first sender you declare will be the one that's used for
transmitting when the “set” command does not specify another sender.

-----------
fs20 sender
-----------

	fs20 sender foo bar:
		cmd "/usr/local/bin/fs20" "--send"

-------------
fs20 receiver
-------------

	fs20 sender foo baz:
		cmd "/usr/local/bin/fs20" "--recv"



====
help
====

This module implements the help command.

"help" is able to examine sub-commands, so if the "foo" command has a
sub-command named "bar", "help foo bar" will list its info.

Of course, if you also happen to have a top-level "foo bar" command,
you're SOL. So don't do that. ☺

======
ifelse
======

This module implements basic conditional blocks.

	laod ifelse
	load bool
	load logging
	block:
		if true:
			log TRACE "Everything is OK."
		else if true:
			log PANIC "This never happens."
		else:
			log PANIC "Something is *seriously* broken!"

"else" does not work at top level, due to an implementation
detail that's difficult to circumvent, but you can always use a block:
wrapper (as in the example, above).

This module does not by itself implement anything you can actually test
for; that's in other modules.

"help conditions" lists which conditions you can test for.

All conditions can be negated by writing "if not" instead of "if".

====
list
====

This module implements a couple of rarely-used commands to list and
examine internal data structures.

-----------
list module
-----------

Shows the list of loaded modules, terminated by a single dot.

You can append the name of a loaded module to examine details.

-----------
list worker
-----------

Shows the list of program snippets that listen for events, ordered by
priority.

You can append the name of a worker to examine details.

=======
logging
=======

This module controls debug output.

---
log
---

Without arguments, it shows a list of the available logging levels,
sorted by priority.

	log

With one argument, it states that debug output of all levels up to the
one specified by the argument shoudl be reported.

	log DEBUG

With more than one argument, the first argument specifies the level at
which the rest of the arguments will get logged.

	log TRACE "You are here."

Log output will go to all terminals which listen to logging at that level
(or less).

========
on_event
========

This is the main event handler module. It translates system events to
executed code, which usually includes triggering even more events.

---
on:
---

Execute statements when an event happens. The parameters of the event
need to correspond 1:1 to the parameters of the "on:" command.

A limited form of wildcard is available: A parameter "*" matches
anything; the actual value is available as "$1" (for the first '*') etc.
Alternately, you can name the parameters:

	load logging
	on foo *whatever:
		name FooBar
		prio 10
		log TRACE "Yes, we get to foo the" $whatever "now!"
		# and whatever else you'd like to do here

	load trigger
	trigger foo bar

Right now there is no support for pattern matching or variable number of
arguments. (One solution is to design your event names in such a way that
you don't need that.)

name
----

This sub-statement names this particular event handler.

Event handlers have system-assigned numbers as well as names, so you can
still delete a handler without naming it.

prio
----

Priority. Default priority is 50. Allowed priorities go from 0 to 100.

Lower-priority handlers are executed first. Only one matching handler
per priority gets executed; which one, depends on random chance (and,
of course, any attached conditions).

This does mean that higher-priority handlers do not start running until
their lower-priority counterparts are completed. If that is not what you
want, use an async: block in the low-priority handler.

------------------
Conditional events
------------------

Sometimes, one event handler would be too complicated — handling both
exceptional circumstances and the "normal case" in one handler calls for
rather large and ultimately unmanageable if/then/else trees.

Thus, there is a way to tell a handler "you don't apply, skip this and
let a different handler process this event". It is simply an “if”
statement, except that (unlike a normal "if") it doesn't have a colon at
the end or an indented block below.

One important usage of this is an alarm system. If you have activated
your alarm system, you want something entirely different to happen when,
say, somebody turns on the light in your office.

	on switch * office *:
		prio 10
		if state on alarm
		trigger alert intruder

	# … some code in an entirely different location
	on switch on office whatever:
		do-whatever-to-turn-this-light-on

The default priority is 50. Currently there is no way to run a handler
when a lower-prio handler did not skip ahead; I'm not convinced that
such a feature is needed.

------------
next handler
------------

This command skips ahead to the next event handler which matches the
event in question.

It has the same effect as an "if false" conditional (see previous
section), but it's more readable.

Usually, you use that at the end of a handler to state that the next one
should also run. Conditionals, on the other hand, are usually used to
selectively cause an event to be skipped, so they're used at the
beginning of a handler.

Note that the effects of a "next handler" end at the end of an event
and do not propagate through a "sync trigger":

	on foo:
		log TRACE one
		sync trigger bar
		log TRACE two
	on bar:
		skip next
		log TRACE "beware: this is ignored"

will still print

	TRACE> one
	TRACE> two

-------
list on
-------

Lists all event handlers.

You can append the name or number of a handler to show details for
that handler.

------
del on
------

Deletes a handler from the system. You need to specify either its number
or its name.

	del on FooBar

------------
if exists on
------------

A test whether a handler exists. Handy to avoid a runtime error if you
don't know whether one exists.

	if exists on FooBar:
		del on FooBar

=======
monitor
=======

You may want HomEvenT to watch external variables (temperature, wind,
whatever). Reading external data may be subject to hard errors (the
external bus is down), soft errors (intermittent false readings),
and other problems.

This module periodically samples 

load monitor
load tests
monitor fake 10 30 1:
	name tempsens livingroom
	delay for 10sec
	require 3 1.5
	retry 5 1sec

--------------------------
monitor SUBSYSTEM DEVICE …
--------------------------

This is the basic command to set up a monitor. How to address an
external device is up to that subsystem; see the appropriate bus module
on how to specify the parameters necessary to address the device in
question.

This command has a couple of parameters:

name NAME
---------

The name of that monitor. If you don't name it, the system will assign
something boring and non-descriptive.

delay for TIME
--------------

Interval between two measurement attempts. See the ‹wait for› command for
specifics.

delay until TIME
----------------

An alternate way to specify the time of each measurement attempt. See
the ‹wait until next› command for specifics. (The first measurement after
turning on the monitor will use ‹wait until› semantics.)

You can specify both ‹delay for› and ‹delay until›. Both will apply.

require NUM RANGE
-----------------

Require NUM measurements which are within RANGE of each other for the
monitor to return a valid result.

The system will report the average of at least NUM values, after the 
data which differ most from the average have been discarded.

retry NUM TIME
--------------

If the measurement has to be repeated because the requirement, above, is
not met, delay for TIME; don't retry more often than NUM times.

If the requirements are not met after NUM times, stop measuring and
report an error.

alarm INTERVAL
--------------

If a valid measurement results in a value whose difference to the
last-reported datum exceeds INTERVAL, an alarm event is posted.

high LIMIT
----------
If a valid measurement reaches or exceeds the limit, an alarm event is
posted.

You can append a second value; if you do, the monitored value must be
below that value for the alarm to be re-enabled.

low LIMIT
---------
If a valid measurement reaches or exceeds the limit, an alarm event is
posted.

You can append a second value; if you do, the monitored value must be
above that value for the alarm to be re-enabled.

limit LOW HIGH
--------------
Measurements which are not within the range defined by LOW and HIGH will
be treated as errors. Use a star ("*") to specify that no limit should
apply.


stopped
-------

This subcommand actually tells the monitor to not start executing
immediately. A common reason for this is that the event handlers
which use the monitor have not been set up yet.

delta
-----

This command tells the monitor to report differences between one value
and the next, instead of absolute measurements. You can use this e.g. to
get events for a counter's increments instead of the absolute value.

There's no handling of overflows yet.

You can say "delta up" to not trigger an event for negative values.

Note that at this point, the delta denotation is only used for events;
the other parameters all apply to the absolute values that get read from
the hardware. This will probably change in the future.

--------------------
update monitor NAME:
--------------------

This command is the same as the one above, except that it modifies an
existing monitor instead of creating a new one.

The "delta", "name" and "stopped" commands are not available.

----------------
del monitor NAME
----------------

Remove this monitor from the system.

------------
list monitor
------------

Displays a list of known monitors. You may add the name for further
details on a particular monitor.

	list monitor
	list monitor tempsens livingroom

------------------
start monitor NAME
------------------

Start monitoring this variable. No effect if already running.

-----------------
stop monitor NAME
-----------------

Stop monitoring this variable. No effect if already stopped.

--------------------
var monitor VAR NAME
--------------------

This statement assigns the value that has been reported last to the
variable VAR.

	monitor …:
		name tempsens livingroom
		…
	block:
		var monitor temp tempsens livingroom
		log INFO It is now $temp deg warm inside

This variable will contain the old value during the ‹monitor value›
event; this means that it will not be set at all until this event has
been completed the first time. See the ‹null› test (in the “bool”
module) for an example.

Note that for "delta" monitors, this will contain the absolute value.

-----
Tests
-----

if exists monitor NAME
----------------------

Checks if this monitor has been set up.

if running monitor NAME
-----------------------

Checks if the monitor is currently operational.

if low monitor NAME
--------------------

Checks if the monitor is currently below the low threshold.

if high monitor NAME
--------------------

Checks if the monitor is currently above the high threshold.

-------------------
The passive monitor
-------------------

If there is no dedicated monitoring for a device, you can set up a
passive monitor. It will send start/stop events when you should
start/stop feeding raw values to it.

monitor passive:
----------------

Set up the monitor.

set monitor VALUE NAME
----------------------

Feed a raw measurement to this monitor.

===
net
===

This module implements a simple, bi-directional, line-oriented TCP
connection.

Lines are delimited by LF (\n) characters. CR (\r) is stripped on
receipt, but not sent.

--------------------------------
connect net ‹name› ‹host› ‹port›
--------------------------------

Establish a connection. If broken, the link will automatically be
restored if possible.

	connect net fhz server.local 7072

---------------------
disconnect net ‹name›
---------------------

Drop the named connection.

--------
list net
--------

Show all known connections. You can add a connection name for details on
that connection.

---------------------------
send net ‹name› ‹whatever…›
---------------------------

Send the text after the connection name to the server, delimited with a
line feed.

-----
Tests
-----

if exists net ‹name›
--------------------

Check that a connection with this name has been configured.

if connected net ‹name›
-----------------------

Check that the connection with this name is up.

====
path
====

This module implements file existence checks.

---------------------
if exists file "name"
---------------------

True if the name points to a file (or to a link which points to a file).

--------------------------
if exists directory "name"
--------------------------

True if the name points to a directory (or to a link which points to a
directory).

---------------------
if exists path "name"
---------------------

True if the name points to something (file, directory, device, …)


=======
onewire
=======

This module provides basic access to 1wire devices. 1wire is a serial
bus by Dallas Semiconductor (who bought Maxim, which developed this
bus). It can run on cheap wiring (one pair, preferably twisted) and does
not require a separate power supply; usually, though, 1wire buses run
over Cat5 cable and do have powered wires.

HomEvenT does not access the 1wire bus directly. Instead, it talks to
one or more “owserver” processes which may run on separate hosts. Check
the “owfs” project at ‹http://owfs.sourceforge.net› for details.

The owfs server translates the machine-readable attributes of a device
to nice, human-readable parameters and values. Check its documentation
for details.

1wire uses °C for temperature measurements. Provide a patch
to set the Fahrenheit flag if you *really* want to change that.

One can attach and remove devices to and from a 1wire bus while the bus
is running. Also, electrical problems like interference may cause bus
operation to be sporadic. HomEvenT therefore retries some bus
operations, but of course it can't fix everything.

HomEvenT's 1wire bus scanner tries to prioritize bus accesses in order
to not block other tasks too long. However, 1wire definitely is not a
real-time bus; you can have *either* a complicated bus topology or
devices which do A/D conversion, *or* a bus with switches or other
real-time input or output devices; you definitely shouldn't connect both
to the same bus.


---------------
connect onewire
---------------

Establish a named server connection. 

	connect onewire MAIN localhost 4304
	connect onewire MAIN 4304
	connect onewire MAIN

The above three statements are equivalent.

HomEvenT will scan the bus every five minutes (or every minute if there
was an error) and provide events for newly connected or removed devices.

------------------
disconnect onewire
------------------

Remove the named connection.

	disconnect onewire MAIN

-----------
dir onewire
-----------

Causes a directory listing on the bus. This is strictly for human
consumption.

	dir onewire MAIN
	dir onewire MAIN "bus.0"
	dir onewire MAIN "1F.C9B004000000" "main"
	dir onewire MAIN "1F.C9B004000000" "main" "20.394309000000"


If you know the device ID, you can list the contents of that device's
directory.

	dir onewire "10.68D839010800"

Without arguments, a list of all bus IDs known to the system is printed.

	dir onewire

-----------
var onewire
-----------

Reads the contents of a named 1wire device register.

The value is read once, when the statement is executed – not when the
variable is accessed. Use the ‹monitor› command if you want to look for
changes.

	block:
		var onewire TEMP "10.68D839010800" temperature
		trigger temp current $TEMP

------------
list onewire
------------

Show which buses are connected to the system.

With the bus name as additional argument, shows details about that bus.

Alternately, you can use a device ID as an additional argument;
HomEvenT will print details about that device. That information will
allow you to use standard owfs commands on the device without searching
the bus for it, which can get tricky if you want to find out where it
just got disconnected from. :-/

-----------
set onewire
-----------

Writes a value to a 1wire device register.

	set onewire 37.5 "10.68D839010800" temphigh

---------------
monitor onewire
---------------

This monitor watches a onewire device.

switch
------

This dedicated monitoring subcommand allows you to control an output
port to extend the range of your measurement.

	switch ‹port› ‹low› ‹high›

Initially, the port is set to zero. If the measured value is higer than
‹high›, the port is set to one, the measurement is repeated, and the
difference between ‹high› and ‹low› is added to the value. If the
measured value then goes below ‹low›, the port is set to zero again.

If ‹low› is larger than ‹high›, the port is set to one initially.
‹low› and ‹high› are swapped. (Doing anything else doesn't make sense …)

One common test subject is a photoresistor.

	+5V --- PHOTO --+-- R1 --+-- R2 --- GND
	                |        |
	              sensor    port

The port is a pull-down output: thus, this setup switches resistance
between R1 and R1+R2, which allows us to measure the wide range of
resistance which a typical photoresistor exhibits.

‹low› and ‹high› need to be calculated so that

* when the photoresistor's resistance is such that the voltage at the
  sensor is at ‹high›, switching on the port will set the voltage to
  ‹low›
* the rate of change is roughly equal.

These conditions are satisfied when R(photo) = sqrt(R1*(R1+R2)).
So if R1=100Ω and R2=10kΩ, R(photo) would be 1005Ω, V(high) 4.55 Volt
and V(low) 0.45 Volt.

	switch PIO.D 4.55 0.45

Of course, these values may be somewhat off due to tolerances in
resistor values and input voltage. The debug output and a
high-resolution RRD graph are good tools for fine-tuning these values.

wind
----

This is a special mode to interpret the AAG wind vane position.

The vane moves a magnet which controls a circle of eight reed relais,
connected to four voltage converters (vielding 0, 2.5, or 5 V). The
result is a floating-point number from zero (inclusive) to 16
(exclusive) which indicates the direction from North (0) through East
(4), South (8) and West (12) to North again (16).

As the vane is mounted on a horizontal bar, it's not always convenient
to orient it so that it points North. The first (optional) parameter is 
an offset which is subtracted from the raw data so that the reported 
value is correct.

Because the vane sometimes swings around rather erratically, a
configurable moving-average damper will be applied. The second parameter
(default: 0.1) can be described as "How much do I trust this value to be
correct".

In my situation, where the vane is mounted on top of a pitched roof,
I have to say "not a whole lot", and compensate by checking for new
values fairly often:

	monitor onewire "98D100000000" volt.ALL:
		name wind dir
		delay for 0.5
		wind 14 0.01

Caveat: If the wind changes to the exact opposite direction, the
moving-average calculation method employed here can arbitrarily delay
reporting the new correct value.

-----
Tests
-----

exists onewire
--------------

Check if a device has ever been found.

	if not exists onewire "10.68D839010800":
		trigger OhNo

exists onewire bus
------------------

Check if a connection has been created.

	if not exists onewire bus MAIN: connect onewire MAIN

connected onewire
-----------------

Check if a device has been seen and is currently on a well-connected
bus.

	if connected onewire "10.68D839010800":
		set onewire 5 "10.68D839010800" templow

connected onewire bus
---------------------

Check if the bus is currently connected to a server.


===
rrd
===

This module provides basic access to RRD databases.

RRD is an acronym for "round-robin database". They're ideal for storing
data for which you want to generate both short-term and long-term
graphs. Basically, a number of data sources get consolidated into one or
more archives. The HomEvenT support of rrdtool is concerned *only*
with supplying data to rrd.

You create these databases with 'rrdtool'.

A typical RRD create statement looks like this:

	rrdtool create /path/to/the.rrd DS:test:GAUGE:60:0:5 RRA:...

"test" is the name of the data source. An RRD archive can have multiple
data sources.

Note that the RRD file is not kept open between accesses;
the Python-RRD library doesn't afford that.


---
rrd
---

Supply a mnemonic name for an RRD.

	rrd "/path/to/the.rrd" test foo bar

This names the data source "test" in the RRD file at /path/to/the.rrd
"foo bar". As usual, the name can consist of multiple words to simplify
event handling later on.


-------
del rrd
-------

Removes that name from the system.

	del rrd foo bar


--------
list rrd
--------

Enumerates the RRDs known to the system.

	>>> list rrd
	foo bar : /path/to/the.rrd test

When you supply the RRD nam as an argument, details for the RRD data
source are printed. Names and values are the same as reported by the
"rrdtool info" command, for the data source in question.

Right now there is no way to query for other RRD information; it's out
of scope for HomEvenT.


-------
set rrd
-------

This allows you to actually store a value in an RRD data set.

	on foobar *OLD *NEW:
		rrd set $NEW foo bar

The last_ds attribute will then be equal to $NEW, and other RRD values
will have been updated as appropriate.


-------
var rrd
-------

This statement assigns the current value of an RRD dataset's attribute
to a name.

	block:
		var rrd whatever last_ds foo bar
		log DEBUG "Your last foobar was" $whatever


-----
Tests
-----

exists rrd NAME
---------------

Check if an RRD has already been created.

	if exists rrd foo bar: del rrd foo bar


===
ssh
===

This module provides secure shell access to HomEvenT.

You need to load it this way:

	load block
	load ssh
	async:
		ssh directory "/some/persistent/path"
		listen ssh 50022
		auth ssh NAME "PUBLIC_KEY"
	.

The port number is, of course, your choice.

ssh needs a persistent host key, which is stored in the directory in
question. You should use "async:" because the first time you do this,
creating the host key may take some time. The directory in question
will then contain a private host key. You need to protect that file so
that nobody can impersonate your HomEvenT server.

After that, "ssh -l NAME -p 50022 localhost" will connect you to a
HomEvenT command line. Basic line editing and (non-persistent) history
is provided.

The SSH connection does not accept passwords for authorization:
passwords need to be stored someplace secure, and HomEvenT does not
aspire to be able to do that. Instead, you need to create a public key
(assuming that you don't already have one):

	ssh-keygen

The resulting public file (typically named with a ".pub" extension)
contains a number of words (separated by spaces). One is very long and
typically starts with a couple of "A" characters. Use that as the
PUBLIC_KEY, above.

You can add multiple users. You can of course safely use your
existing public key if you already have one.

There's no provision for limiting access: anybody who can log in to
the server can do everything.

The command "exit" will terminate your ssh connection.

Using a HomEvenT command on the ssh command line is not yet supported.

-------------------
auth ssh USER "KEY"
-------------------

Allow that user to log in with that public key.

-----------------
del auth ssh USER
-----------------

Prevent that user from logging in.

---------------------
ssh directory "/path"
---------------------

SSH needs a persistent host key. This directory will be used to
store (or retrieve) the key.

SSH will not be operational until after this command has completed.

---------------
listen ssh PORT
---------------

Accept SSH connections on this port. The standard SSH port is 22, but
usually your normal system SSH occupies that port. Besides, port numbers
below 1024 can only be allocated by root. You do not want to run
HomEvenT with root privileges!

=====
state
=====

This module limits state variables. These are not yet persistent, but
they will be.

---------
set state
---------

Sets a state to some value.

	set state on livingroom lamp1

This will trigger an event if the old state was not "on":

	state - on livingroom lamp1

"-" is used when the state variable is new.

The event is processed synchronously. It is an error for an event
handler to change the same state variables.

For this reason, you need to wrap any activity that's either long-term,
or likely to change the state again, in an async: block. In other
words, this is broken and will cause you a lot of headache:

	# DO NOT DO THIS
	load onewire
	load on_event
	load wait
	load trigger

	on state * on outside *lamp:
		trigger onewire switch on outside $lamp
		wait for 5min:
			name outside $lamp
		trigger onewire switch off outside $lamp

The correct solution would be, depending on whether you want the switch
to prolong the timeout …:

	# DO THIS (the switch turns off the lamp)
	load block
	load ifelse

	on state * on outside *lamp:
		if exists wait outside $lamp:
			wait for 5min:
				name outside $lamp
				update
		else:
			async:
				trigger onewire switch on outside $lamp
				wait for 5min:
					name outside $lamp
				trigger onewire switch off outside $lamp

… or turn the lamp off prematurely:

	# DO THIS (the switch turns off the lamp)
	on state * on outside *lamp:
		async:
			if exists wait outside $lamp:
				del wait outside $lamp
			else:
				trigger onewire switch on outside $lamp
				wait for 5min:
					name outside $lamp
			trigger onewire switch off outside $lamp

Note that in the last example, the trigger statement is outside the if:
statement. That is intentional; see "del wait", below, for details.

---------
del state
---------

Causes the system to forget a state variable. A notification event is
triggered:

	state on - livingroom lamp1

The rules on events, above, still apply.

----------
list state
----------

Shows all state variables.

You can append the name of a variable to show additional details.

---------
var state
---------

Sometimes you need a state for further processing.

Arguments are the name of the variable, and the state name.

	block:
		var state light livingroom lamp1
		log DEBUG "The light is" $light

-----
Tests
-----

state
-----

True if a state has a particular value.

	if state on livingroom lamp1:
		log DEBUG "Save energy, man!"

last state
----------

True if a state had a particular value before it was changed to the
current one. As above, the previous value for a new state is "-".

exists state
------------

True if the state has been defined at all.

	if exists state NAME:
		log DEBUG "Yay!"

locked state
------------

True if the state is currently being updated, i.e. an event handler is
working (and blocking!) on it.

Ideally, you should split up your design into more events instead of
doing a test like this, but if you *have* to …

	async:
		while locked state SOMETHING:
			wait for 1 sec
		set state SOMETHING off

Obviously, a loop like this should never run synchronously.



====
time
====

Sometimes you need the current (or some future) time for further
processing.

--------
var time
--------

This statement assigns the current time, or some attribute thereof, to a
variable.

	block:
		var time now + 10sec
		wait until = $now

=======
trigger
=======

This module implements a way to create new events from script code.

-------
trigger
-------

Launches a new event. The event is run asynchronously, i.e. execution
will continue while the event is processed.

	trigger foo bar

------------
sync trigger
------------

The event is run synchronously, i.e. execution will stall until this
event has been processed. That means if the trigger says

	on foo bar:
		switch on lamp
		wait for 1h
		switch off lamp

then the statement after the "sync trigger" will be executed exactly one
hour later.

====
wait
====

This module implements a method to wait for a specified amount of time.

All time parameters accept a timestamp as their first argument. This
timestamp defaults to (and cannot be smaller than) the current time; it
specifies the absolute minimum time at which the wait trigger.


      N sec / min / hour / day / month / week / year
	        mo/tu/we/th/fr/sa/su: day of week; N mon…sun: month's Nth
			monday etc
			      N wk: ISO week number

--------
wait for
--------

This statement will delay execution by the specified amount.

	wait for 10min - 5sec

Used as a compound statement, you can specify details.

The following interval specifications are accepted:

	s sec second seconds
	m min minute minutes
	h hr hour hours
	d dy day days
	w wk week weeks
	m mo month months
	y yr year years


name
----

Assign a name to a wait statement. This name causes the waiter to be
unique, i.e. there can only be one wait statement with that name in the
whole system. If you try to execute a wait statement with the same
name as one that's still pending, an error will be triggered.

	wait for 5min:
		name "Brew some tea"


If you do not name a wait statement, it will have a system-assigned
unique name.

update
------

This marks a wait: statement as updating another waiter, instead of
waiting itself. For example:

	async:
		wait for 10sec:
			name Test
		trigger FooBar

	wait for 1sec:
		name Test
		update
	
	trigger DoNow

will trigger the FooBar event after one second; the DoNow event will
trigger immediately. 

An error will be raised if the original statement is no longer active.

----------
wait until
----------

This powerful statement lets you wait until some (fixed) conditions
related to the current time are true.

	async:
		wait until 0 min 0 sec
		log DEBUG full hour

If the conditions are already true, this statement will not wait at all.

The following (absolute) time specifications are accepted. You need to
specify a number in front of them, because it's always *some* day:

	s sec second seconds
	m min minute minutes
	h hr hour hours
	d dy day days (of the month)
	w wk week weeks (of the year)
	m mo month months
	y yr year years

Naming a day with a preceding number means the n'th day in that week; as
above, the number can be negative. Without a number, the next day of
that name will be used which matches all the other criteria.

	mo mon monday
	tu tue tuesday
	we wed wednesday
	th thu thursday
	fr fri friday
	sa sat saturday
	su sun sunday

Week 1 is the first week in the year which has a Thursday, even if
it spans the previous year: "tue 1 wk 2004yr" will return 2003-12-30.

"3 wed 4mo 2003yr" is 2003-04-16, as that's the third Wednesday of that
month. "-3 wed" means the same thing, because April of 2004 has five
Wednesdays.

Note that negative values always apply to the end of the next-larger
interval. "11hr -10sec" means 11:00:50 because the next-larger interval
to seconds is a minute. The only exception are numbered days, which
refer to the month.

---------------
wait until next
---------------

Like above, except that it will wait until the next time the time matches.

	async:
		while True:
			wait until next 0 min
			trigger play sound "hourly chime.ogg"

This will prevent repeating the gong for a full minute. ;-)

----------
wait while
----------

This will wait until the condition is no longer true.
The above could therefore also have been written as:

	async:
		while True:
			wait while 0 min
			wait until 0 min
			trigger play sound "hourly chime.ogg"

except that it's ugly. ☺

---------
list wait
---------

This command shows which wait statements are currently active.

You can append the name of a wait statement to show additional details.

--------
del wait
--------

Cancels a given wait. The statements which waited for it are *not*
executed — this includes stuff in upper blocks, other event handlers
which tried to process whatever was blocked by the wait, etc.

This is the reason why, in the last example under "set state", above,
the command to turn off the lamp is outside the if: statement.

If you do want these statements to run, update the waiter to zero
seconds instead of canceling it.

--------
var wait
--------

You can access the time when a wait command will end.

	var wait THEN NAME

This is useful, of course, for adding this timestamp to other wait
statements. See also the “time” module.


-----
Tests
-----

if wait before/after
--------------------

You can use this test to find out whether an event triggers before or
after another one.

	async:
		wait for 10min:
			name YAWN
	block:
		var time tomorrow time += 0h 0min 0sec
		if wait after $tomorrow YAWN:
			log DEBUG the YAWN timer ends on a different day


if exists wait
--------------

You can use this statement to test if a waiter is pending.

See the example under "set state", above.


if locked wait
--------------

You can use this statement to test whether a notification event on that
waiter is running.


