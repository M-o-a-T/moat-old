.. 
    Copyright © 2007-2012, Matthias Urlichs <matthias@urlichs.de>
    .
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    .
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License (included; see the file LICENSE)
    for more details.

===
avg
===

This module adds basic averaging capability. Measurement data, which
can arrive at any time, are accumulated.

-----------
avg ‹name…›
-----------

Creates a new average with that name. Its value is initially empty. You
feed new data into the average whenever they arrive, and a new average
will be calculated dynamically.

This averaging module is based on the naïve premise that the measured
doesn't change until you set a new value, i.e. there's no interpolation.
This is arguably the worst way to handle things, but it's deterministic.

---------------------
set avg value ‹name…›
---------------------

Feed a new value into this average. Values can arrive at any time.

-------------------
var avg VAR ‹name…›
-------------------

Set VAR to the current value of this average. This is based on the
premise that the value that's been fed into the agerage by the last
"set" command has not changed in the meantime.

Note that if you do this immediately after feeding a new value into
an average, said new value will not have accrued any time. Thus,

    avg test
    set avg 1 test
    wait: for 1
    set avg 2 test
    var avg X test
    log The value is $X

will log something like 1.0001. Wait another second to get the
expected 1.5.

-----
Tests
-----

if exists avg ‹name…›
---------------------

Checks whether this averager has been created.

=====
block
=====

This module implements two quick-and-dirty compound statements to
control execution flow.

------
block:
------

This just groups more than one statement into a sequence. It's not very
useful by itself, but a good "if true" replacement.

------
async:
------

Like "block:", but does *not* wait for completion before continuing to
interpret input: the statements will run in a parallel thread.

	load logging
	load wait
	async:
		log TRACE One
		wait: for 1
		log TRACE two

A "skip next" command inside the async: block will terminate executing
that block, but cannot have any effect beyond that.

----------
skip this:
----------

This will cause the following block to not be executed.
(It still needs to be composed of known words.)
It's a handy "comment this out" statement.

====
bool
====

This module provides a cuple of basic conditionals. 
See “ifelse” for details.

true
----

Always true.

false
-----

Always false.

null ARG
--------

This conitional tests whether the argument is not set.
This is important e.g. for monitoring.

	monitor foo:
		…
	on monitor value *FOO foo:  #*
		var monitor OLDFOO foo
		if null $OLDFOO:
			log TRACE first time fooing around
		else:
			log TRACE checking $FOO against old $OLDFOO

equal A B
---------

Test if A and B are equal (either both null, or both same-valued
floating point numbers, or identical strings).

Obviously, this statement makes sense only if at least one of these
values is a variable. ☺

"less" and "greater" tests are also available.


====
data
====

This module implements a couple of rarely-used commands to list and
examine internal data structures.

----
list
----

This generic command lists all data structures that the system is
willing to tell you more about.

The first form lists all names of data structures.
It skips structure with no current members.

You can append the name of a data structure to show a list of
data structures of a particular type.

You can then append the name of a data structure to show some
additional details about that particular item.

    >> list
    module
    .
    >> list module
    data :: provides a couple of common data access functions
    net :: Basic line-based TCP access
    .
    >> list module net
    name: net
    path: moat.modules.net.py
    info: Basic line-based TCP access
    .
    >> 


---
del
---

    Many things which the “list” command shows you can be removed from
    the system.

    >> list module net

    The individual modules' documentation will tell you more.

-----------
list module
-----------

Shows the list of loaded modules, terminated by a single dot.

You can append the name of a loaded module to examine details.

-----
Tests
-----

exists …
--------

Nearly everything that can sensibly be deleted can also be tested for.

	if exists module data:
		del module data

======
errors
======

Basic error handling.

Usually, an error causes all processing to be aborted which waits for
the failed statement to complete. In a non-async block, that happens
to be the entire rest of the script. This module provides some ways to
change that, as well as a command to explicitly trigger an error.

---
try
---

This command catches all errors which happen inside.

	try:
		set onewire FOO nonexistent

-----
catch
-----

This command needs to follow a ‹try› or ‹catch› block. It grabs the
error from that block.

	block:
		try:
			trigger error foo bar
		catch:
			log DEBUG Somebody did a $1 with a $2

As you see, the error's parameters are passed in.

As an alternate form, you may mention the parameters explicitly.
If the error has not been triggered manually, or does not fit the list
in some way, processing continues to the next ‹catch› block.

	block:
		try:
			trigger error foo bar
		catch foo *what:
			log DEBUG Somebody must have been fooing around with the $what
		catch:
			log DEBUG Somebody did a $1 with a $2

Finally, named system errors can be caught:
	
	block:
		try:
			log TRACE $foobar
		catch AttributeError:
			log DEBUG somebody did something stupid
			log error DEBUG

Errors within the ‹catch› block fall down to the next ‹catch› statement.
If there is none, the error is handled normally.


-------------
trigger error
-------------

As seen in the above examples, this statement will cause an error to be
emitted.

	block:
		try:
			block:
				trigger error foo bar
				log TRACE this will never be seen
			log TRACE Neither will this be
		catch:
			log TRACE HEY we got an error of $1

------------
report error
------------

Caught errors are normally not reported because the ‹catch› block is
supposed to handle them. If you want (or need) to, however, you can 

	block:
		try:
			trigger error foo bar
		catch:
			log error DEBUG


=======
example
=======

A snippet of module loader code to help you get going.


=======
fs20avr
=======

This module interfaces to an AVR microcontroller which implements the
FS20 on-air protocols. This eats much fewer resources and will be much
more reliable than using a soundcard interface or similar with the
fs20tr module.

See the fs20/avr directory for details.

The controller is expected to send keepalive messages every second.

----------------
fs20 avr ‹name…›
----------------

Register a new interface.

remote ‹host› [‹port›]
----------------------

The interface is accessed by opening a TCP connection to the specified
host and port.

The port defaults to 54083.

port ‹device› [‹speed›]
-----------------------

The interface is accessed by opening a specific serial port.

The port speed defaults to 57600 baud.

This method is not implemented yet.

cmd ‹command…›
--------------

The interface is accessed by talking to the given program vis
stdin+stdout.

This method is not implemented yet.


-----
Tests
-----

connected fs20 avr ‹name…›
--------------------------

Check whether the connection to that device is operational.



======
fs20em
======

This module adds decoding of FS20 EM devices.

You also need to tell the radio receiver+decoder to actually analyze and
forward these messages. See the audio documentation for details.

Appropriate events are emitted every time an EM message is received.

-------------
fs20 em NAME…
-------------

Register a device.

    fs20 em inside
        code thermo_hygro 1


code TYPE ID
------------

Tells MoaT which type of device this is and the ID that's set on it.

You can get the list of known types with "help fs20 em".

Device IDs range from zero to seven.


scale type factor offset
------------------------

Raw values of TYPE get multiplied by FACTOR, then OFFSET is added,
just before generating the event for a measurement.

You can use a star instead of writing one or zero, respectively, to
document that you didn't measure the value (as opposed to knowing that
the value is zero or one).

    fs20 em inside
        code thermo_hygro 1
        scale humidity * 1.2


timeslot [sec]
--------------

There are only eight possible addresses for each device type, but they
send at pre-defined and reasonably accurate intervals. Using this
command, the system tries to separate them by installing a timeslot
(with sane values and the same name) for this devices.

The optional value is the duration of the time slot; it defaults to one
second. If you have a slow computer, increasing this value may be
necessary.

Note that you need to declare one timeslot-equipped FS20-EM device,
insert the batteries, and wait for correct measurement events to show up
before you declare the timeslot for any other device. Otherwise MoaT
will have no way to determine which device is which.

In addition to using a timeslot, MoaT tries to separate devices by
considering the previous measurement: if a data packet can be placed in
two slots, the device with the closest values will be used.

----------------
del fs20 em NAME
----------------

Forget about this device.


======
fs20tx
======

This module adds decoding of TX2/TX3 devices. These are 433 MHz temperature
and humidity sensors.

Appropriate events are emitted every time a TX message is received.

-------------
fs20 tx NAME…
-------------

Register a device.

    fs20 tx inside
        code thermo 1


code TYPE ID
------------

Tells MoaT which type of device this is and the ID that's set on it.

You can get the list of known types with "help fs20 tx".

Device IDs range from zero to 127.


scale type factor offset
------------------------

Raw values of TYPE get multiplied by FACTOR, then OFFSET is added,
just before generating the event for a measurement.

You can use a star instead of writing one or zero, respectively, to
document that you didn't measure the value (as opposed to knowing that
the value is zero or one).

    fs20 tx inside
        code hygro 1
        scale humidity * 1.2


----------------
del fs20 tx NAME
----------------

Forget about this device.


==========
fs20switch
==========

Use this module to register FS20 devices.

MoaT uses this registration only for naming, but doesn't
distinguish between senders and receivers, since it treats incoming
signals as mere events — you need to specify any more convoluted logic
in your own code.

Incoming messages will be reported as events, of course; see the events
documentation for details.

----------------
fs20 switch NAME
----------------

This command declares a group of FS20 devices which share a common
“house code”, an 8-digit sequence (digits 1,2,3,4 only ⇒ in effect a
16-bit number).

code HOUSECODE
--------------

This specifies the house code for the group.

add DEVCODE NAME
----------------

This subcommand is used to declare a device.
The device code is four digits long (1 to 4, again).

	fs20 switch inside actors:
        code 12344321
		add living room light:
            code 2143

You can use the same command to modify a house or device code.

	fs20 switch inside actors:
		del living room light
		add living room light:
            code 2144

Note that the broadcast and/or group control codes, which are defined as
having "44" in the last and/or first two digits of the device code,
are not handled by MoaT in any special way. This is intentional:
your MoaT code needs to know (and document) _anyway_ which signal
affects which device.


---------
send fs20
---------

Send a FS20 message.

	set fs20 on - living room light

This of course does not guarantee that the lights really turn on.
Among other reasons, FS20 is not a bidirectional protocol, so messages
can and do get lost. A common workaround is to add a timer which, when
somebody pushes the light-on button again within two seconds or so,
causes the command to repeat instead of turning the light back off.


======
fs20tr
======

This module allows you to use external processes to send and receive
FS20 datagrams.

The datagram format is simple: The complete frame, encoded in hex.
The checksum is not treated in any special way and arbitrary datagram
lengths are supported.

Note that regulations limit any one sender to take up at most 1% of he
total available bandwidth. This module does not yet enforce this limit.

The first sender you declare will be the one that's used for
transmitting when the “set” command does not specify another sender.

-----------
fs20 sender
-----------

	fs20 sender foo bar:
		cmd "/usr/local/bin/fs20" "--send"

-------------
fs20 receiver
-------------

	fs20 sender foo baz:
		cmd "/usr/local/bin/fs20" "--recv"



====
help
====

This module implements the help command.

"help" is able to examine sub-commands, so if the "foo" command has a
sub-command named "bar", "help foo bar" will list its info.

Of course, if you also happen to have a top-level "foo bar" command,
you're SOL. So don't do that. ☺

======
ifelse
======

This module implements basic conditional blocks.

	laod ifelse
	load bool
	load logging
	block:
		if true:
			log TRACE "Everything is OK."
		else if true:
			log PANIC "This never happens."
		else:
			log PANIC "Something is *seriously* broken!"

"else" does not work at top level, due to an implementation
detail that's difficult to circumvent, but you can always use a block:
wrapper (as in the example, above).

This module does not by itself implement anything you can actually test
for; that's in other modules.

"help conditions" lists which conditions you can test for.

All conditions can be negated by writing "if not" instead of "if".


=======
logging
=======

This module controls debug output.

---
log
---

Without arguments, it shows a list of the available logging levels,
sorted by priority.

	log

With one argument, it states that debug output of all levels up to the
one specified by the argument shoudl be reported.

	log DEBUG

With more than one argument, the first argument specifies the level at
which the rest of the arguments will get logged.

	log TRACE "You are here."

Log output will go to all terminals which listen to logging at that level
(or less).

--------
list log
--------

Show the currently-configured loggers.

You can add a logger's name to show further details amout that logger.

---------------
del log ‹name…›
---------------

Delete the named logger.

------------------------
log limit ‹kind› ‹level›
------------------------

Limit logging of the named kind of event to that level. This is useful
when you want to trace someting, but aren't interested in all the "event"
messages that the system generates.



========
on_event
========

This is the main event handler module. It translates system events to
executed code, which usually includes triggering even more events.

---
on:
---

Execute statements when an event happens. The parameters of the event
need to correspond 1:1 to the parameters of the "on:" command.

A limited form of wildcard is available: A parameter "*" matches
anything; the actual value is available as "$1" (for the first '*') etc.
Alternately, you can name the parameters:

	load logging
	on foo *whatever:   #*
		name FooBar
		prio 10
		log TRACE "Yes, we get to foo the" $whatever "now!"
		# and whatever else you'd like to do here

	load trigger
	trigger foo bar

Right now there is no support for pattern matching or variable number of
arguments. (One solution is to design your event names in such a way that
you don't need that.)

name
----

This sub-statement names this particular event handler.

Event handlers have system-assigned numbers as well as names, so you can
still delete a handler without naming it.

prio
----

Priority. Default priority is 50. Allowed priorities go from 0 to 100.

Lower-priority handlers are executed first. Only one matching handler
per priority gets executed; which one, depends on random chance (and,
of course, any attached conditions).

This does mean that higher-priority handlers do not start running until
their lower-priority counterparts are completed. If that is not what you
want, use an async: block in the low-priority handler.

------------------
Conditional events
------------------

Sometimes, one event handler would be too complicated — handling both
exceptional circumstances and the "normal case" in one handler calls for
rather large and ultimately unmanageable if/then/else trees.

Thus, there is a way to tell a handler "you don't apply, skip this and
let a different handler process this event". It is simply an “if”
statement, except that (unlike a normal "if") it doesn't have a colon at
the end or an indented block below.

One important usage of this is an alarm system. If you have activated
your alarm system, you want something entirely different to happen when,
say, somebody turns on the light in your office.

	on switch * office *:   #*
		prio 10
		if state on alarm
		trigger alert intruder

	# … some code in an entirely different location
	on switch on office whatever:
		do-whatever-to-turn-this-light-on

The default priority is 50. Currently there is no way to run a handler
when a lower-prio handler did not skip ahead; I'm not convinced that
such a feature is needed.

------------
next handler
------------

This command skips the remaining commands in this event handler.

Usually, you use this in a complex loop or nested if statement to
immediately exit the handler.

-------
list on
-------

Lists all event handlers.

You can append the name or number of a handler to show details for
that handler.

------
del on
------

Deletes a handler from the system. You need to specify either its number
or its name.

	del on FooBar

------------
if exists on
------------

A test whether a handler exists. Handy to avoid a runtime error if you
don't know whether one exists.

	if exists on FooBar:
		del on FooBar

============
Input/Output
============

This is, strictly speaking, not a module of its own.
Instead, other modules may register I/O handlers which can be accessed with
common commands.

The "tests" module contains code for "fake" input and output handlers.
A fake output simply sets the fake input with the same name to whatever it is set to.

---------------------------
input ‹name› ‹typ› ‹param…›
---------------------------

Declare a named input of the given type.

---------------------------
output ‹name› ‹typ› ‹param…›
---------------------------

Declare a named output of the given type.

-----------------
Common Parameters
-----------------

name
----

If the input or output should be named with a multi-word name, use this
attribute.

	output wago whichever 1 2:
		name light outside

----------------
del input ‹name›
----------------

Forgets that this named input exists.

-----------------
del output ‹name›
-----------------

Forgets that this named output exists.

---------
var input
---------

Sets a variable to whatever the input is when this statement is executed.

Subsequent statements may retrieve the value with '$var'.

	input magic … :name thermometer outside
	var input temp thermometer outside
	if less $temp 0:
		log WARN it is cold out there

----------
var output
----------

Sets a variable to whatever the output is (if the hardware supports that)
or is supposed to be (if not), when this statement is executed.

Subsequent statements may retrieve the value with '$var'.


----------
set output
----------

Sets the output to the value given.

	set output on light wherever

-----
Tests
-----

input ‹value› ‹name›
--------------------

Check whether this input has the given value.


output ‹value› ‹name›
---------------------

Check whether this output has / is supposed to have the given value.


=======
monitor
=======

You may want MoaT to watch external variables (temperature, wind,
whatever). Reading external data may be subject to hard errors (the
external bus is down), soft errors (intermittent false readings),
and other problems.

This module periodically samples an analog or counted input. It actually
gets its data either by actively polling a device; see the specific monitor
subcommands for details.

load monitor
load tests
monitor fake 10 30 1:
	name tempsens livingroom
	delay for 10sec
	require 3 1.5
	retry 5 1sec

--------------------------
monitor SUBSYSTEM DEVICE …
--------------------------

This is the basic command to set up a monitor. How to address an
external device is up to that subsystem; see the appropriate module's
documentation on how to specify the parameters necessary to address the
device in question.

The subsystem is "input" if you want to watch an input variable;
however, note that the variable is always polled. Subsystems which
send data on their own will register their own subsystems.

This command has a couple of parameters:

name NAME
---------

The name of that monitor. If you don't name it, the system will assign
something boring and non-descriptive.

delay for TIME
--------------

Interval between two measurement attempts. See the ‹wait› command for
specifics.

delay until TIME
----------------

An alternate way to specify the time of each measurement attempt. See
the ‹wait until next› command for specifics. (The first measurement after
turning on the monitor will use ‹wait until› semantics.)

You can specify both ‹delay for› and ‹delay until›. Both will apply.

require NUM RANGE
-----------------

Require NUM measurements which are within RANGE of each other for the
monitor to return a valid result.

The system will report the average of at least NUM values, after the 
most extreme data have been discarded.

retry NUM TIME
--------------

If the measurement has to be repeated because the requirement above, is
not met, delay for TIME; don't retry more often than NUM times.

If the requirements are not met after NUM times, stop measuring and
report an error.

scale factor offset
-------------------

Raw values get multiplied by FACTOR, then OFFSET is added,
just before processing them further.

You can use a star instead of writing a factor of one or an offset of
zero, to document that you didn't measure the value (as opposed to
*knowing* that the value is one or zero, respectively).

alarm INTERVAL
--------------

If a valid measurement results in a value whose difference to the
last-reported datum exceeds INTERVAL, an alarm event is posted.

high LIMIT
----------
If a valid measurement reaches or exceeds the limit, an alarm event is
posted.

You can append a second value; if you do, the monitored value must be
below that value for the alarm to be re-enabled.

low LIMIT
---------
If a valid measurement reaches or exceeds the limit, an alarm event is
posted.

You can append a second value; if you do, the monitored value must be
above that value for the alarm to be re-enabled.

limit LOW HIGH
--------------
Measurements which are not within the range defined by LOW and HIGH will
be treated as errors. Use a star ("*") to specify that no limit should
apply.


stopped
-------

This subcommand tells the monitor to not start executing immediately.
A common reason for this is that the event handlers which use the
monitor have not been set up yet.


delta
-----

This command tells the monitor to report differences between one value
and the next, instead of absolute measurements. You can use this e.g. to
get events for a counter's increments instead of the absolute value.

There's no handling of overflows yet.

You can say "delta up" to not trigger an event for negative values.

Note that at this point, the delta denotation is only used for events;
the other parameters of the "monitor" statement all apply to the
absolute values that get read from the hardware. This will probably
change in the future.

--------------------
update monitor NAME:
--------------------

This command is the same as the one above, except that it modifies an
existing monitor instead of creating a new one.

The "delta", "name" and "stopped" commands are not available.

----------------
del monitor NAME
----------------

Remove this monitor from the system.

------------
list monitor
------------

Displays a list of known monitors. You may add the name for further
details on a particular monitor.

	list monitor
	list monitor tempsens livingroom

------------------
start monitor NAME
------------------

Start monitoring this variable. No effect if already running.

-----------------
stop monitor NAME
-----------------

Stop monitoring this variable. No effect if already stopped.

--------------------
var monitor VAR NAME
--------------------

This statement assigns the value that has been reported last to the
variable VAR.

	monitor …:
		name tempsens livingroom
		…
	block:
		var monitor temp tempsens livingroom
		log INFO It is now $temp deg warm inside

This variable will contain the old value during the ‹monitor value›
event; this means that it will not be set at all until this event has
been completed the first time. See the ‹null› test (in the “bool”
module) for an example.

Note that for "delta" monitors, this will contain the absolute value.

-----
Tests
-----

if exists monitor NAME
----------------------

Checks if this monitor has been set up.

if running monitor NAME
-----------------------

Checks if the monitor is currently operational.

if low monitor NAME
--------------------

Checks if the monitor is currently below the low threshold.

if high monitor NAME
--------------------

Checks if the monitor is currently above the high threshold.

-------------------
The passive monitor
-------------------

If there is no dedicated monitoring for a device, you can set up a
passive monitor. It will send start/stop events to signal that you should
start/stop feeding raw values to it.

monitor passive:
----------------

Set up the monitor.

set monitor VALUE NAME
----------------------

Feed a raw measurement to this monitor.

===
net
===

This module implements a simple, bi-directional, line-oriented TCP
connection.

Lines are delimited by LF (\n) characters. CR (\r) is stripped on
receipt, but not sent.

--------------------------------
connect net ‹name› ‹host› ‹port›
--------------------------------

Establish a connection.

	net fhz server.local 7072

If you want to use multi-word connection names, supply the name as an
additional argument.

    net localhost 7:
        name foo bar

If you want to reconnect automatically, attach an event handler to the
disconnect events. Same for the error event, if the connection could
not be established in the first place.

-------------------------------
listen net ‹name› ‹host› ‹port›
-------------------------------

Same as above, but wait for the remote side to connect to me instead
of connecting yourself.

Multiple connections are supported. They're numbered sequentially, by
appending an integer to the name.

	EVENT: net connect baz zaz 1

Currently, there is no authorization. You might want to use the kernel
firewall to control the port, and/or only export non-sensitive
information.


---------------
del net ‹name…›
---------------

Drop the named connection.

--------
list net
--------

Show all known connections. You can add a connection name for details on
that connection.

---------------------------
send net ‹name› ‹whatever…›
---------------------------

Send the text after the connection name to the server, delimited with a
line feed.

If the connection's name consists of more than one word, use an
additonal "to" argument:

    # echo port
    net connect localhost 7:
        name foo bar
    
    send net "This is a test":
        to foo bar

… except that you need to let the sending be triggered by the
corresponding "connect" event.

You can also use Smalltalk-ish single-line syntax:

    send net "This is a test" :to foo bar

-----
Tests
-----

if exists net ‹name›
--------------------

Check that a connection with this name has been configured.

if connected net ‹name›
-----------------------

Check that the connection with this name is up.

====
path
====

This module implements file existence checks.

---------------------
if exists file "name"
---------------------

True if the name points to a file (or to a link which points to a file).

--------------------------
if exists directory "name"
--------------------------

True if the name points to a directory (or to a link which points to a
directory).

---------------------
if exists path "name"
---------------------

True if the name points to something (file, directory, device, …)


===
pwm
===

This module implements pulse-width (and related) modulation. That is, it
translates a number between 0 and 1 into a sequence of on/off events, so
that the fraction of time the signal is on equals that number.

Modes exist for pulse width modulation (constant time between off ⇒ on
events) and pulse density modulation (the "on" time is constant but the
"off" time varies, or vice versa).

Support for minimal interval duration (e.g. a furnace needs to be on for
at least a minute, otherwise there'd be wasted gas but no actual heat)
is not yet implemented.


---
pwm
---

Create a new PWM. Note that you do need a couple of sub-commands,
depending on the PWM's type.

type
----

This (required) sub-statement controls the type of the pulse modulator.
Implemented are "PWM", "PDM" (constant 'on' time) and "iPDM" (constant
'off' time).

    pwm foo bar:
        type PDM

interval
--------

This (required) sub-statement sets the common interval. For PWM style
controllers, this is the total control interval; for PDM, the duration
of the pulse or pause.

    pwm foo:
        interval 12

----------
update pwm
----------

Change the parameters of a PWM. Use sub-statements as above.

Currently, changing the PWM type is not supported.


-------
set pwm
-------

Sets the PWM's goal value. The PWM is started if it's not running
already.

    set pwm 0.123 foo

There is no way to explicitly stop a PWM off; however, setting the value
to zero will set the state to "off" and not emit any further events,
which is more or less the same thing.

-----
Tests
-----

on pwm
------

Tests if the PWM is running, i.e. has had a value assigned to it.

    if on pwm foo:
        do whatever

NB: Testing if the PWM is currently in its "on" phase is not supported
directly. If you need that, capture the event and set a state variable.


=======
onewire
=======

This module provides basic access to 1wire devices. 1wire is a serial
bus by Dallas Semiconductor (who bought Maxim, which developed this
bus). It can run on cheap wiring (one pair, preferably twisted) and does
not require a separate power supply; usually, though, 1wire buses run
over Cat5 cable and do have powered wires.

MoaT does not access the 1wire bus directly. Instead, it talks to
one or more “owserver” processes which may run on separate hosts. Check
the “owfs” project at ‹http://owfs.sourceforge.net› for details.

The owfs server translates the machine-readable attributes of a device
to nice, human-readable parameters and values. Check its documentation
for details.

1wire uses °C for temperature measurements. Provide a patch
to set the Fahrenheit flag if you *really* want to change that.

One can attach and remove devices to and from a 1wire bus while the bus
is running. Also, electrical problems like interference may cause bus
operation to be sporadic. MoaT therefore retries some bus
operations, but of course it can't fix everything.

MoaT's 1wire bus scanner tries to prioritize bus accesses in order
to not block other tasks too long. However, 1wire definitely is not a
real-time bus; you can have *either* a complicated bus topology or
devices which do A/D conversion, *or* a bus with switches or other
real-time input or output devices; you definitely shouldn't connect both
to the same bus.


---------------
connect onewire
---------------

Establish a named server connection. 

	connect onewire MAIN localhost 4304
	connect onewire MAIN 4304
	connect onewire MAIN

The above three statements are equivalent.

MoaT will scan the bus every five minutes (or every minute if there
was an error) and provide events for newly connected or removed devices.

------------------
disconnect onewire
------------------

Remove the named connection.

	disconnect onewire MAIN

------------
scan onewire
------------

Scan a onewire bus. The command waits until the bus has been scaned
completely.

Note that this should only be used in exceptional circumstances, as a
scan is executed periodically anyway.

-----------
dir onewire
-----------

Causes a directory listing on the bus. This is strictly for human
consumption.

	dir onewire MAIN
	dir onewire MAIN "bus.0"
	dir onewire MAIN "1F.C9B004000000" "main"
	dir onewire MAIN "1F.C9B004000000" "main" "20.394309000000"


If you know the device ID, you can list the contents of that device's
directory.

	dir onewire "10.68D839010800"

Without arguments, a list of all bus IDs known to the system is printed.

	dir onewire

-----------
var onewire
-----------

Reads the contents of a named 1wire device register.

The value is read once, when the statement is executed – not when the
variable is accessed. Use the ‹monitor› command if you want to look for
changes.

	block:
		var onewire TEMP "10.68D839010800" temperature
		trigger temp current $TEMP

------------
list onewire
------------

Show which buses are connected to the system.

With the bus name as additional argument, shows details about that bus.

Alternately, you can use a device ID as an additional argument;
MoaT will print details about that device. That information will
allow you to use standard owfs commands on the device without searching
the bus for it, which can get tricky if you want to find out where it
just got disconnected from. :-/

-----------
set onewire
-----------

Writes a value to a 1wire device register.

	set onewire 37.5 "10.68D839010800" temphigh

---------------
monitor onewire
---------------

This monitor watches a onewire device.

switch
------

This dedicated monitoring subcommand allows you to control an output
port to extend the range of your measurement.

	switch ‹port› ‹low› ‹high›

Initially, the port is set to zero. If the measured value is higer than
‹high›, the port is set to one, the measurement is repeated, and the
difference between ‹high› and ‹low› is added to the value. If the
measured value then goes below ‹low›, the port is set to zero again.

If ‹low› is larger than ‹high›, the port is set to one initially.
‹low› and ‹high› are swapped. (Doing anything else doesn't make sense …)

One common test subject is a photoresistor.

	+5V --- PHOTO --+-- R1 --+-- R2 --- GND
	                |        |
	              sensor    port

The port is a pull-down output: thus, this setup switches resistance
between R1 and R1+R2, which allows us to measure the wide range of
resistance which a typical photoresistor has, without requiring more
fancy circuitry.

‹low› and ‹high› need to be calculated so that

* when the photoresistor's resistance is such that the voltage at the
  sensor is at ‹high›, switching on the port will set the voltage to
  ‹low›
* the rate of change is roughly equal.

These conditions are satisfied when R(photo) = √(R1*(R1+R2)).
So if R1=100Ω and R2=10kΩ, R(photo) would be 1005Ω, V(high) 4.55 Volt
and V(low) 0.45 Volt.

	switch PIO.D 4.55 0.45

Of course, these values may be somewhat off due to tolerances in
resistor values and input voltage. The debug output and a
high-resolution RRD graph are good tools for fine-tuning these values.

wind
----

This is a special mode to interpret the (old) AAG wind vane's position.

The vane moves a magnet which controls a circle of eight reed relais,
connected to four voltage converters (yielding 0, 2.5, or 5 V). The
result is a floating-point number from zero (inclusive) to 16
(exclusive) which indicates the direction from North (0) through East
(4), South (8) and West (12) to North again (16).

As the vane is mounted on a horizontal bar, it's not always convenient
to orient it so that it points North. The first (optional) parameter is 
an offset which is subtracted from the raw data so that the reported 
value is correct.

Because the vane swings around rather erratically in turbulent wind
conditions (unavoidable when it's mounted on top of a sloped roof), a
configurable moving-average damper will be applied. The second parameter
(default: 0.1) can be described as "How much do I trust this value to be
correct".

	monitor onewire "98D100000000" volt.ALL:
		name wind dir
		delay for 0.5
	        delta 0.5
		wind 14 0.01

The ‹list monitor› command will report (a moving average of) the
difference between the latest "raw" measurement and the average.

The "turbulence" parameter reflects how much the wind measurements
vary. 0: the vane is stationary; 1: all directions are equally likely.

Do not use the "require" and "retry" parameters: they don't make sense here.

Using the ‹delta› parameter is a good idea if you don't want your
system to get flooded with monitor messages.

-----
Tests
-----

connected onewire
-----------------

Check if a device has been seen and is currently on a well-connected
bus.

	if connected onewire "10.68D839010800":
		set onewire 5 "10.68D839010800" templow

connected onewire bus
---------------------

Check if the bus is currently connected to a server.


===
rrd
===

This module provides basic access to RRD databases.

RRD is an acronym for "round-robin database". They're ideal for storing
data for which you want to generate both short-term and long-term
graphs. Basically, a number of data sources get consolidated into one or
more archives. The MoaT support of rrdtool is concerned *only*
with supplying data to rrd.

You create these databases with 'rrdtool'.

A typical RRD create statement looks like this:

	rrdtool create /path/to/the.rrd DS:test:GAUGE:60:0:5 RRA:...

"test" is the name of the data source. An RRD archive can have multiple
data sources.

Note that the RRD file is not kept open between accesses;
the Python-RRD library doesn't afford that.


---
rrd
---

Supply a mnemonic name for an RRD.

	rrd "/path/to/the.rrd" test foo bar

This names the data source "test" in the RRD file at /path/to/the.rrd
"foo bar". As usual, the name can consist of multiple words to simplify
event handling later on.


-------
del rrd
-------

Removes that name from the system.

	del rrd foo bar


--------
list rrd
--------

Enumerates the RRDs known to the system.

	>>> list rrd
	foo bar : /path/to/the.rrd test

When you supply the RRD nam as an argument, details for the RRD data
source are printed. Names and values are the same as reported by the
"rrdtool info" command, for the data source in question.

Right now there is no way to query for other RRD information; it's out
of scope for MoaT.


-------
set rrd
-------

This allows you to actually store a value in an RRD data set.

	on foobar *OLD *NEW:
		rrd set $NEW foo bar

The last_ds attribute will then be equal to $NEW, and other RRD values
will have been updated as appropriate.


-------
var rrd
-------

This statement assigns the current value of an RRD dataset's attribute
to a name.

	block:
		var rrd whatever last_ds foo bar
		log DEBUG "Your last foobar was" $whatever


-----
Tests
-----


===
ssh
===

This module provides secure shell access to MoaT.

You need to load it this way:

	load block
	load ssh
	async:
		ssh directory "/some/persistent/path"
		listen ssh 50022
		auth ssh NAME "PUBLIC_KEY"
	.

The port number is, of course, your choice.

ssh needs a persistent host key, which is stored in the directory in
question. You should use "async:" because the first time you do this,
creating the host key may take some time. The directory in question
will then contain a private host key. You need to protect that file so
that nobody can impersonate your MoaT server.

After that, "ssh -l NAME -p 50022 localhost" will connect you to a
MoaT command line. Basic line editing and (non-persistent) history
is provided.

The SSH connection does not accept passwords for authorization:
passwords need to be stored someplace secure, and MoaT does not
aspire to be able to do that. Instead, you need to create a public key
(assuming that you don't already have one):

	ssh-keygen

The resulting public file (typically named with a ".pub" extension)
contains a number of words (separated by spaces). One is very long and
typically starts with a couple of "A" characters. Use that as the
PUBLIC_KEY, above.

You can add multiple users. You can of course safely use your
existing public key if you already have one.

There's no provision for limiting access: anybody who can log in to
the server can do everything.

The command "exit" will terminate your ssh connection.

Using a MoaT command on the ssh command line is not yet supported.

-------------------
auth ssh USER "KEY"
-------------------

Allow that user to log in with that public key.

-----------------
del auth ssh USER
-----------------

Prevent that user from logging in.

---------------------
ssh directory "/path"
---------------------

SSH needs a persistent host key. This directory will be used to
store (or retrieve) the key.

SSH will not be operational until after this command has completed.

---------------
listen ssh PORT
---------------

Accept SSH connections on this port. The standard SSH port is 22, but
usually your normal system SSH occupies that port. Besides, port numbers
below 1024 can only be allocated by root. You do not want to run
MoaT with root privileges!

=====
state
=====

This module limits state variables. These can be persistent if you want
them to.

-----
state
-----

Create a new state.

    state foo bar

saved
-----

The state will be read from the database if it exists there.

It will also be written every time it's changed with a "set state"
command.

The state will not be read from the database at any other time.


trigger new
-----------

Send a new-value event when the state is created. The old value is
the string "-"; so is the new value unless you set it to something else.

trigger old
-----------

Like above, but used when the state is restored from the database.

value ‹whatever›
----------------

Set the initial value


---------
set state
---------

Sets a state to some value.

	set state on livingroom lamp1

This will trigger the following event, assuming that the old state was "off":

	state off on livingroom lamp1

The old state is "-" if the state variable has not been set before.

The event is processed synchronously. It is an error for an event
handler to change the same state variable. Setting a variable to the
value it already has is not a change and will not result in an error, or
an event for that matter.

NB: that error, like the event that triggered it, is handled synchronously.
However, it will *not* be propagated out of the original "set state" command
because that command did change the variable's value as intended.

For this reason, you need to wrap any activity that's long-term (and/or
or likely to change the state again) in an async: block. In other
words, this is broken and will cause you a lot of headache:

	# DO NOT DO THIS
	load onewire
	load on_event
	load wait
	load trigger

	on state * on outside *lamp:
		trigger switch on outside $lamp
		wait outside $lamp:
			for 5min
		trigger switch off outside $lamp

The correct solution would be, depending on whether you want the switch
to prolong the timeout …:

	# DO THIS (the switch turns off the lamp)
	load block
	load ifelse

	on state * on outside *lamp:
		if exists wait outside $lamp:
			wait outside $lamp:
			    for 5min
				update
		else:
			async:
				trigger switch on outside $lamp
				wait outside $lamp:
                    for 5min
				trigger switch off outside $lamp

… or turn the lamp off prematurely:

	# DO THIS (the switch turns off the lamp)
	on state * on outside *lamp:
		async:
			if exists wait outside $lamp:
				del wait outside $lamp
			else:
				trigger switch on outside $lamp
				wait outside $lamp
                    for 5min
			trigger switch off outside $lamp

Note that in the last example, the trigger statement is outside the if:
statement. That is intentional; see "del wait", below, for details.

---------
del state
---------

Causes the system to forget a state variable. A notification event is
triggered:

	state on - livingroom lamp1

The rules on events, above, still apply.

This command will remove a saved state from the database.

----------
list state
----------

Shows all state variables.

You can append the name of a variable to show additional details.

---------
var state
---------

Sometimes you need a state for further processing.

Arguments are the name of the variable, and the state name.

	block:
		var state light livingroom lamp1
		log DEBUG "The light is" $light

-----
Tests
-----

state
-----

True if a state has a particular value.

	if state on livingroom lamp1:
		log DEBUG "Save energy, man!"

last state
----------

True if a state had a particular value before it was changed to the
current one. As above, the previous value for a new state is "-".

saved state
-----------

As above, but tests whether a saved state exists in the database.

locked state
------------

True if the state is currently being updated, i.e. an event handler is
working (and blocking!) on it.

Ideally, you should split up your design into more events instead of
doing a test like this, but if you *have* to …

	async:
		while locked state SOMETHING:
			wait: for 1 sec
		set state SOMETHING off

Obviously, a loop like this should never run synchronously.



======
syslog
======

This module allows you to set up logging through syslog.

------
syslog ‹facility› ‹level› [‹destination›]
------

Sets up a logger which transmits messages to syslog.

    The 'facility' and 'level' arguments are the well-known strings
    from syslog; read "man syslog.conf" for details.

    The destination can be a local file name (must be a Unix datagram
    socket) or a host/port tuple (must be a UDP socket).

    There are no separate commands to list or delete loggers;
    syslog is part of logging, so you can use those from the
    "logging" module.


====
time
====

Sometimes you need the current (or some future) time for further
processing.

--------
var time
--------

This statement assigns the current time, or some attribute thereof, to a
variable.

	block:
		var time now + 10sec
		wait until = $now


========
timeslot
========

Some events happen, or need to happen, at pre-defined intervals.
Examples:

* send a status message to a controller every 116 seconds which doesn't
  have its receiver turned on at other times

* turn on my receiver every 116 seconds and listen for a status message

MoaT controls this with time slots.

----------------
timeslot ‹name…›
----------------

Define a named timeslot.

A slot has these states:

* off: It's not active and will not trigger.

* next: Between intervals.

* pre: At the beginning of the interval, while the "begin" event is triggered.

* during: Between the "begin" and "end" events.

* post: At the end of the interval, while the "end" event is triggered.

A timeslot can be re-synchronized. As the sync point often lies in the
middle of the slot, no begin event will be issued when re-syncing -- the
correct time for issuing that event has already passed.


every ‹time spec›
-----------------

Declare how much time shall elapse between interval starts.

There is no default.

for ‹time spec›
---------------

Declare how long the interval in question should be.

The default is one second.

stopped
-------

Typically the timeslot is started immediately. This command leaves the
slot in the "off" state until it is started.

offset ‹0…1›
------------

The timeslot's "during" event triggers sometime within the slot. This
parameter specifies when that should happen.

The default is 0.5, i.e. in the middle of the interval.

-----------------------
update timeslot ‹name…›
-----------------------

Modify an existing slot. You can use all of the above parameters, except
"stop".

----------------------
start timeslot ‹name…›
----------------------

Start to run this slot. The event is not triggered. If the slot has never
been started yet, the start time will be the current time plus one
"every" interval.

The timeslot may not be active unless "now" is used; see below.

now
---

Re-sync the slot. The event is triggered immediately, except if the
event handler is currently running or the timeslot is in the "post" state.


------------------------
var timeslot VAR ‹name…›
------------------------

Set the variable to the slot's state.


-----
Tests
-----


if exists timeslot ‹name…›
--------------------------

Test if the slot has been declared.


if running timeslot ‹name…›
---------------------------

Test if the slot is active, i.e. will trigger sometime soon.


if in timeslot ‹name…›
----------------------

Test whether the timeslot is in "pre", "during", or "post" state.


=======
trigger
=======

This module implements a way to create new events from script code.

-------
trigger
-------

Launches a new event. The event is run asynchronously, i.e. execution
will continue while the event is processed.

	trigger foo bar

param ‹key› ‹value›
-------------------

Attach ‹value› to the event as a named parameter.

	on foo bar:
		log DEBUG Hello $name
	trigger foo bar:
		param name Joe
	
will log "Hello Joe".


log
---

Event execution is normally logged at the TRACE level.
You can change the level with this statement.

	trigger bad foobar:
		log ERROR

====
wago
====

This module implements a line-oriented protocol to a Wago I/O controller
running Linux. The protocol is implemented by the code in the "wago"
submodule. Adaption to other controllers, notably those using the kernel's
GPIO interface, should be very simple.

----
wago
----

Declares a Wago input controller.

	wago localhost 59069:
		name test
    	ping 1
    	monitor 0.1

The destination port defaults (for now) to 59995.

name
----

The name of this controller. If not set, the host name is used.


ping
----

Periodically send a "ping" command, which checks that the device is still present.

The optional parameter is the ping interval; it defaults to once per minute.

monitor
-------

Tell the device how often to poll its inputs. This overrides the command line
the server has been started with; the default is three seconds.

----------
input wago
----------

Declare a digital input.

Direct parameters are the server name, the I/O card on the server, and the
port number on the card.

	input wago test 1 1:
		name foo bar
		to on

name
----

The port name. If not set, the server and port is the name, i.e. "test 1 1"
in this case.

to
--

Optional; if this parameter is used, an event will be triggered when the port changes to the indicated state ("on", "off", or "both"). If no parameter is used, "both" is assumed.

-----------
output wago
-----------

Declare a digital output.

The "name" subcommand is used as in "wago input".

You can change the output with the "set wago" command, described below.

	output wago test 1 2:
		name baz out
		default off

default
-------

If used, the output will be changed to this state ("on" or "off") after
starting MoaT and initially connecting to a server.

Upon reconnection, MoaT's current state will be restored.


------------
monitor wago
------------

This command declares a counter which watches one of the controller's input
lines and periodically reports how often it changed in a specific interval.

	monitor wago test 1 1:
		name foo bar
		delta
		delay for 30
		to off

The time given in the "delay for" parameter will be sent to the device
to set the reporting interval. Note that there will not be any measurements
when the port does not change.

See the "monitor" command for further options. The "delta" option, in
particular, should almost always be used.

The "delay until" parameter cannot be used, as the monitor frequency is
controlled by setting parameters at the remote system. The code there does
not depend on an accurate time-of-day clock.

to
--

Declare which state change will be counted ("on", "off" or "both").
The default is "on".

----------------
list wago server
----------------

This command shows which servers are currently known to the system.

You can append the name of a server to show additional details.

----------
list input
----------

This command lists input lines and their currrent state.

You can add the name of a line to view additional details.

-----------
list output
-----------

This command lists input lines and their currrent state.

You can add the name of a line to view additional details.

------------------
var input VAR name
------------------

Set the variable VAR to the current state of the named input.

-----
Tests
-----

input NAME
----------

Check if the named input is set.

====
wait
====

This module implements a method to wait for a specified amount of time.

All time parameters accept a timestamp as their first argument. This
timestamp defaults to (and cannot be smaller than) the current time; it
specifies the absolute minimum time at which the wait trigger.


      N sec / min / hour / day / month / week / year
	        mo/tu/we/th/fr/sa/su: day of week; N mon…sun: month's Nth
			monday etc
			      N wk: ISO week number

After a wait statement completes, the timestamp at which it went off is
available in the variable ‹$wait›.

----
wait
----

This statement will delay execution by the specified amount.

	wait tea ready:
        for 10min - 5sec

It is always used as a compound statement.

The following interval specifications are accepted:

	s sec second seconds
	m min minute minutes
	h hr hour hours
	d dy day days
	w wk week weeks
	m mo month months
	y yr year years

Sometimes you want a timer to trigger at precise intervals; say, every
180 seconds. To do this, specify the last time your timer went off (or
should have gone off) as the first argument: if that is in the past,
proper interval calculation will be performed. The minimum interval for
this is two seconds.

The direct arguments to ‹wait› assign a name. This name causes the
waiter to be unique, i.e. there can only be one wait statement with that
name in the whole system. If you try to execute a wait statement with
the same name as one that's still pending, an error will be triggered.

If you do not name a wait statement, it will have a system-assigned
unique name.

update
------

This marks a wait: statement as updating another waiter, instead of
waiting itself. For example:

	async:
		wait Test:
            for 10sec
		trigger FooBar

	wait Test:
		update
        for 1sec
	
	trigger DoNow

will trigger the FooBar event after one second; the DoNow event will
trigger immediately. 

An error will be raised if the original statement is no longer active.

until
-----

This powerful alternate to the "for" specification lets you wait until
some (fixed) conditions related to the current time are true.

	async:
		wait: until 0 min 0 sec
		log DEBUG full hour

If the conditions are already true, this statement will not wait at all.

The following (absolute) time specifications are accepted. You need to
specify a number in front of them, because it's always *some* day:

	s sec second seconds
	m min minute minutes
	h hr hour hours
	d dy day days (of the month)
	w wk week weeks (of the year)
	m mo month months
	y yr year years

Naming a day with a preceding number means the n'th day in that week; as
above, the number can be negative. Without a number, the next day of
that name will be used which matches all the other criteria.

	mo mon monday
	tu tue tuesday
	we wed wednesday
	th thu thursday
	fr fri friday
	sa sat saturday
	su sun sunday

Week 1 is the first week in the year which has a Thursday, even if
it spans the previous year: "tue 1 wk 2004yr" will return 2003-12-30.
There is no week zero.

"3 wed 4mo 2003yr" is 2003-04-16, as that's the third Wednesday of that
month. "-3 wed" means the same thing, because April of 2004 has five
Wednesdays.

Note that negative values always apply to the end of the next-larger
interval. "11hr -10sec" means 11:00:50 because the next-larger interval
to seconds is a minute. The only exception are numbered days, which
refer to the month.

until next
----------

Like above, except that it will wait until the next time the time matches.

	async:
		while True:
			wait: until next 0 min
			trigger play sound "hourly chime.ogg"

This will prevent repeating the gong for a full minute. ;-)

while
-----

This will wait until the condition is no longer true.
The above could therefore also have been written as:

	async:
		while True:
			wait: while 0 min
			wait: until 0 min
			trigger play sound "hourly chime.ogg"

except that it's ugly. ☺

---------
list wait
---------

This command shows which wait statements are currently active.

You can append the name of a wait statement to show additional details.

--------
del wait
--------

Aborts a given wait. The statements which waited for it are *not*
executed — this includes stuff in upper blocks, other event handlers
which tried to process whatever was blocked by the wait, etc.

This is the reason why, in the last example under "set state", above,
the command to turn off the lamp is outside the if: statement.

If you do want these statements to run, update the waiter to zero
seconds instead of canceling it.

--------
var wait
--------

You can access the time when a wait command will end.

	var wait THEN NAME

This is useful, of course, for adding this timestamp to other wait
statements. See also the “time” module.


-----
Tests
-----

if wait before/after
--------------------

You can use this test to find out whether an event triggers before or
after another one.

	async:
		wait YAWN: for 10min
	block:
		var time tomorrow time += 0h 0min 0sec
		if wait after $tomorrow YAWN:
			log DEBUG the YAWN timer ends on a different day


if exists wait
--------------

You can use this statement to test if a waiter is pending.

See the example under "set state", above.

====
AMQP
====

Connect MoaT to an external AMQP messaging server like RabbitMQ.

The message payload typically consists of a JSON string with attributes
that can be sent or received by MoaT. Only simple values (strings or
numbers) are supported.

The AMQP message exchanges need to be "topic" exchanges so that message
filtering works. This is particularly important if you use the same queue
for both directions.

-------------------
connect amqp ‹host›
-------------------

Establish a connection to an AMQP server.

	connect amqp localhost:
		name test foo
		user test test test

name
----

The name of this AMQP connection. If it's a single word, you can also say

	connect amqp test_foo localhost

user
----

Virtual host, user name, and password for establishing the connection.


------------------
listen amqp ‹name›
------------------

Connect to a specific exchange on the named AMQP connection. The routing
key is split up at the dots and used as the event name. The message payload
is interpreted as a JSON hash and attached to the event; if JSON decoding
fails, the payload is attached as the `raw` attribute.

	listen amqp test foo:
		name foo lish
		exchange he_exc
		prefix amqp foo
		strip 1

name
----

The name of this listener.

exchange ‹name›
--------

The AMQP exchange to bind to. Defaults to `moat_event`.

prefix ‹word…›
--------------

These words are prefixed to the routing key of arriving events.

topic
-----

Topic filter. The default is `#`, i.e. no filtering.

strip ‹n›
---------

Removes the first ‹n› elements from the routing key, before prefixing.

If there is no prefix and no stripping, this listener will mark incoming
events as "process directly", i.e. they will not be processed by a
transparent "tell amqp …" command.

shunt
-----

Mark the received event as generated by a `shunt`-ed `tell amqp` command.
This means that the event will not be passed to any other `shunt` handlers,
as that would create an endless loop while not accomplishing anything.

-------------------
tell amqp ‹name…›
-------------------

Forwards all events which match ‹filter…› to an AMQP exchange.
The event name is concatenated with dots and used as the routing key.

Data attached to the event (see `trigger`) are sent as a JSON hash in the
message body. If there is an attribute `raw`, those attribute's content is
sent as-is, all others are ignored.

name ‹name…›
------------

The name of this connection. Used for logging and, of course, to disable it
if you need to.

filter ‹prefix…›
----------------

Only process events with this prefix. You can use '*' to match a single
wildcard, or '"**"' (which you need to quote; this is a small parser bug) 
as the last element, to match any number of words.

If you do not use this sub-statement, all events are forwarded.

exchange ‹name›
---------------

The exchange to use. Defaults to "moat.event".

prefix ‹name…›
--------------

Prefix to prepend to the event's key.

strip ‹n›
---------

Remove the first ‹n› words from the event key before forwarding.

shunt
-----

Events matching this statement will *not* be processed by MoaT.
Instead, you are required to provide a matching `listen amqp` statement.
That statement also needs a `shunt` sub-statement, and it needs to
reconstruct the event (remove any prefix).

------------------
start amqp ‹name…›
------------------

Start processing incoming AMQP messages. You need to call this
once, after executing all of the above AMQP statements.

-----------------
stop amqp ‹name…›
-----------------

Stop processing incoming AMQP messages. You need to call this if you want
to change your SMQP settings for whatever reason. Note that this may cause
a synchronization problem if a message arrives at exactly the wrong time.

--------------
log amqp DEBUG
--------------

Send all logging data to an AMQP queue. You should not listen to that
queue.

name ‹name…›
------------

The name of the connection.

exchange ‹name›
---------------

The exchange to send to; the default is `moat.log`.


--------------------
list amqp connection
--------------------

Returns a list of connections, or deails about one connection.

------------------
list amqp listener
------------------

Returns a list of listeners, or deails about one listener.

